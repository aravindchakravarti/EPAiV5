[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/I7A3K_cM)

[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15486070&assignment_repo_type=AssignmentRepo)

  

# Submission Details:

## Name : Aravind D. Chakravarti

## Email: aravinddcsadguru@gmail.com

![image](https://github.com/user-attachments/assets/98d71470-d901-4db8-a194-a7dfa6751461)

  

# Python Decorators


**Python Decorators** are a powerful and expressive tool that allow you to modify the behavior of functions or classes. They are commonly used to extend the functionality of existing code in a clear and concise manner without modifying the original structure. Decorators wrap another function or method, adding some functionality before or after the wrapped function runs, or even replacing it entirely.

This repository contains various Python decorators and decorator factories for different purposes. The code includes decorators for conditional execution based on the current time, logging function details, access control, authentication, and performance timing.

#### Basic Structure

A decorator in Python is a function that takes another function as an argument, and returns a new function that typically extends or alters the behavior of the original function. The `@decorator` syntax is a shorthand for applying a decorator to a function.

```python
def decorator_function(original_function): 
	def wrapper_function(*args, **kwargs): 
		# Add functionality before 
		result = original_function(*args, **kwargs) 
		# Add functionality after 
		return result 
	return wrapper_function 

@decorator_function 
def display(): 
	print("Hello World")
```
In this example, `decorator_function` is a decorator that adds extra functionality to `display`.

#### Common Uses

-   **Logging**: Automatically log function calls and their parameters.
-   **Access Control**: Restrict access to certain parts of the code based on user roles.
-   **Memoization**: Cache the results of expensive function calls to improve performance.
-   **Validation**: Validate inputs to a function before executing the main logic.

### Decorators Factories

**Decorators Factories** are a more advanced concept where the decorator itself is generated by a factory function. This allows for the creation of decorators that can accept arguments, enabling more dynamic and flexible behavior.

#### Basic Structure

A factory decorator is a function that returns a decorator, which in turn decorates a function.

```python
def decorator_factory(argument): 
	def decorator_function(original_function): 
		def wrapper_function(*args, **kwargs): 
			print(f"Decorator argument: {argument}") 
			result = original_function(*args, **kwargs) 
			return result 
		return wrapper_function 
	return decorator_function 

@decorator_factory("example argument") 
def display(): 
	print("Hello World")
```
In this example, `decorator_factory` takes an argument and returns a decorator, which is then used to decorate `display`.

#### Common Uses

-   **Configuration**: Customize decorators with different configurations.
-   **Conditional Execution**: Apply different behavior based on the arguments passed to the factory.
-   **Parameter Injection**: Inject additional parameters into the decorated function.
## List of Decorators in this Repo

### `odd_it`

This decorator ensures that the decorated function executes only if the current second is an odd number.

**Usage:**

```python

@odd_it

def  my_function():

print("Function executed")

```

### `logger`

  

This decorator logs details about the following

1. Function Name

  

2. Execution Time

  

3. Function Description

  

4. Function annotation

  

5. Called parameters and type

```python

@logger

def  my_function(param1: int, param2: str) -> None:

"""

Example function.

"""

print("Function executed")

```

  

### `decorator_factory`

  

This factory function returns a decorator based on the access level provided. The access levels are:

  

-  `'high'` : Access to 4 variables

-  `'mid'` : Access to 3 variables

-  `'low'` : Access to 2 variables

-  `'no'` : Access to 1 variable

  

```python

@decorator_factory('high')

def  my_function(var1, var2, var3, var4):

print(var1, var2, var3, var4)

```

  

### `authenticate`

  

This decorator factory provides authentication based on a set password. The first argument of the decorated function should be a password.

```python

@authenticate('my_password')

def  secure_function(password: str):

print("Access granted")

```

  

### `timed`

  

This decorator factory measures the average execution time of the decorated function over a specified number of repetitions.

```python

@timed(10)

def  my_function():

print("Function executed")

```
